<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<link href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" rel="stylesheet"/>
<script src="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>

<style>
html, body { margin:0; height:100%; font-family:'Inter', sans-serif; }
.map { width:100%; height:100%; position:absolute; top:0; left:0; }

#controls { position:absolute; top:10px; right:10px; z-index:25; background:white; padding:10px; border:1px solid #ccc; display:flex; flex-direction:column; gap:5px; border-radius:6px; }
#hybridToggle { position:absolute; top:180px; right:10px; z-index:20; background:white; padding:8px; border:1px solid #ccc; cursor:pointer; border-radius:6px; width:40px; height:40px; display:flex; align-items:center; justify-content:center; transition: background 0.2s; }
#hybridToggle.active { background:#ddd; }
#hybridToggle img { width:24px; height:24px; }

#downloadMap { position:absolute; top:130px; right:10px; z-index:20; background:white; padding:8px; border-radius:6px; border:1px solid #ccc; cursor:pointer; width:40px; height:40px; display:flex; align-items:center; justify-content:center; }
#downloadMap svg { width:24px; height:24px; }

button, select, input { font:14px 'Inter', sans-serif; }

#searchBox { width:200px; padding:4px; border-radius:4px; border:1px solid #ccc; z-index:26; position:relative; }
#searchResults { position:absolute; top:38px; right:10px; background:white; border:1px solid #ccc; max-height:180px; overflow-y:auto; width:200px; z-index:30; border-radius:4px; display:none; }

.searchItem { padding:4px 6px; cursor:pointer; }
.searchItem:hover { background:#eee; }

.route-info { position:absolute; top:50px; left:50%; transform:translateX(-50%); background:white; padding:8px 14px; border:1px solid #333; font:14px 'Inter', sans-serif; z-index:25; border-radius:6px; opacity:0.9; pointer-events:none; }
.loading { position:absolute; top:20px; left:50%; transform:translateX(-50%); background:yellow; padding:6px 12px; border-radius:4px; z-index:40; font-weight:bold; display:none; }

.attribution-text { position:absolute; bottom:10px; right:10px; z-index:25; background:rgba(255,255,255,0.85); padding:6px 10px; font:12px 'Inter', sans-serif; border-radius:6px; }
.maptiler-logo { position:absolute; left:10px; bottom:10px; z-index:25; }

.hint-text { position:absolute; top:240px; right:10px; z-index:20; background:rgba(255,255,255,0.95); padding:8px 12px; border:1px solid #ccc; border-radius:6px; font:12px 'Inter', sans-serif; max-width:200px; display:none; }
</style>
</head>
<body>

<div id="map-streets" class="map"></div>
<div id="map-hybrid" class="map" style="display:none;"></div>

<div id="controls">
  <input id="searchBox" type="text" placeholder="Search"/>
  <div id="searchResults"></div>
  <button id="toggleRoute">Enable Routing</button>
  <select id="mode">
    <option value="driving-car">Car</option>
    <option value="foot-walking">Walking</option>
    <option value="cycling-regular">Cycling</option>
  </select>
  <button id="resetRoute">Reset Route</button>
</div>

<div id="downloadMap" title="Download Map">
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" stroke="#5856d6" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 24 24">
    <path d="M9 11a3 3 0 1 0 6 0a3 3 0 0 0 -6 0"/>
    <path d="M17.657 16.657l-4.243 4.243a2 2 0 0 1 -2.827 0l-4.244 -4.243a8 8 0 1 1 11.314 0z"/>
  </svg>
</div>

<div id="hybridToggle">
  <img src="https://raw.githubusercontent.com/finnhound/cartohound/7b3c8e14c393450a26d9d562c99016afad43d83a/stack%20(1).svg" alt="Hybrid Map Icon">
</div>

<div id="route-info" style="
    position: absolute;
    top: 136px;
    right: 70px;
    width: 145px;
    background: rgba(255,255,255,0.85);
    padding: 8px 10px;
    border: 1px solid #333;
    border-radius: 6px;
    font: 14px 'Inter', sans-serif;
    z-index: 25;
    pointer-events: none;
    display: none;
"></div>

<div id="hint-text" class="hint-text">
  <strong>Shift+Click</strong> on route to add waypoints<br>
  <strong>Double-click</strong> waypoints to remove
</div>

<div id="loading" class="loading">Loading...</div>

<div class="attribution-text">
  MapLibre | © openrouteservice.org by HeiGIT | Map data © OpenStreetMap contributors | Tiles © MapTiler
</div>
<a class="maptiler-logo" href="https://www.maptiler.com" target="_blank" rel="noopener">
  <img src="https://api.maptiler.com/resources/logo.svg" alt="MapTiler logo">
</a>

<script>
const ORS_KEY = "eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6IjFjMzkyNDVlOGIyNjQxYjVhMDRhNWEwNjdlMTM4MDc0IiwiaCI6Im11cm11cjY0In0=";
const MT_KEY = 'kUOJqqeRX1BMaXctsgK5';
const STREETS_URL = `https://api.maptiler.com/maps/019b2817-43ac-7a98-b15b-c204722a617b/style.json?key=${MT_KEY}`;
const HYBRID_URL = `https://api.maptiler.com/maps/hybrid/style.json?key=${MT_KEY}`;

const savedView = JSON.parse(localStorage.getItem('mapView') || 'null');
let currentStyle = localStorage.getItem('mapStyle') || 'streets';
let routingEnabled = JSON.parse(localStorage.getItem('mapRouteEnabled') || 'false');
let routingMode = document.getElementById('mode').value;

let routePoints = [];
let startMarker = null;
let endMarker = null;
let waypointMarkers = [];
const routeInfo = document.getElementById('route-info');
const loadingEl = document.getElementById('loading');
const searchBox = document.getElementById('searchBox');
const searchResults = document.getElementById('searchResults');
const hintText = document.getElementById('hint-text');

// SVG markers
const defaultPinSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="#5856d6" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M9 11a3 3 0 1 0 6 0a3 3 0 0 0 -6 0"/><path d="M17.657 16.657l-4.243 4.243a2 2 0 0 1 -2.827 0l-4.244 -4.243a8 8 0 1 1 11.314 0z"/></svg>`;
const startPinSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="#00c7be" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M9 11a3 3 0 1 0 6 0a3 3 0 0 0 -6 0"/><path d="M17.657 16.657l-4.243 4.243a2 2 0 0 1 -2.827 0l-4.244 -4.243a8 8 0 1 1 11.314 0z"/></svg>`;
const endPinSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="#ff9500" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M9 11a3 3 0 1 0 6 0a3 3 0 0 0 -6 0"/><path d="M17.657 16.657l-4.243 4.243a2 2 0 0 1 -2.827 0l-4.244 -4.243a8 8 0 1 1 11.314 0z"/></svg>`;

// Initialize maps
const mapStreets = new maplibregl.Map({ container:'map-streets', style:STREETS_URL, center: savedView?.center||[0,0], zoom: savedView?.zoom ?? 1, attributionControl:false, preserveDrawingBuffer:true });
const mapHybrid = new maplibregl.Map({ container:'map-hybrid', style:HYBRID_URL, center: savedView?.center||[0,0], zoom: savedView?.zoom ?? 1, attributionControl:false, preserveDrawingBuffer:true });
[mapStreets,mapHybrid].forEach(m=>{ m.addControl(new maplibregl.NavigationControl({showCompass:true, showZoom:true}),'top-left'); });

// Hybrid toggle
const hybridToggleEl = document.getElementById('hybridToggle');
function showHybrid(isHybrid) {
  hybridToggleEl.classList.toggle('active', isHybrid);
  if(isHybrid){ 
    document.getElementById('map-streets').style.display='none'; 
    document.getElementById('map-hybrid').style.display='block'; 
    mapHybrid.resize(); 
    // Re-add all markers to hybrid map
    if(startMarker) startMarker.addTo(mapHybrid);
    if(endMarker) endMarker.addTo(mapHybrid);
    waypointMarkers.forEach(wp => wp.addTo(mapHybrid));
  } else { 
    document.getElementById('map-streets').style.display='block'; 
    document.getElementById('map-hybrid').style.display='none'; 
    mapStreets.resize(); 
    // Re-add all markers to streets map
    if(startMarker) startMarker.addTo(mapStreets);
    if(endMarker) endMarker.addTo(mapStreets);
    waypointMarkers.forEach(wp => wp.addTo(mapStreets));
  }
  currentStyle = isHybrid?'hybrid':'streets';
  localStorage.setItem('mapStyle',currentStyle);
}
showHybrid(currentStyle==='hybrid');
hybridToggleEl.onclick = ()=>showHybrid(currentStyle==='streets');

// Sync & persist map views
let syncing=false;
function syncView(src,tgt){ if(syncing) return; syncing=true; const c=src.getCenter(), z=src.getZoom(); tgt.jumpTo({center:[c.lng,c.lat], zoom:z}); syncing=false; }
mapStreets.on('move',()=>syncView(mapStreets,mapHybrid));
mapHybrid.on('move',()=>syncView(mapHybrid,mapStreets));
function saveView(){ const activeMap = currentStyle==='streets'?mapStreets:mapHybrid; const c=activeMap.getCenter(), z=activeMap.getZoom(); localStorage.setItem('mapView',JSON.stringify({center:[c.lng,c.lat], zoom:z})); }
mapStreets.on('moveend', saveView); mapHybrid.on('moveend', saveView);

// Routing UI
const toggleRouteBtn = document.getElementById('toggleRoute');
function updateRouteButton(){ 
  toggleRouteBtn.textContent = routingEnabled?'Disable Routing':'Enable Routing'; 
  updateSearchPlaceholder(); 
  hintText.style.display = (routingEnabled && startMarker && endMarker) ? 'block' : 'none';
}
updateRouteButton();
toggleRouteBtn.onclick = ()=>{ 
  routingEnabled = !routingEnabled; 
  localStorage.setItem('mapRouteEnabled',routingEnabled); 
  updateRouteButton(); 
  if(!routingEnabled){ 
    clearRoute(); 
  } 
};

document.getElementById('mode').onchange = function(){ 
  routingMode = this.value; 
  if(routePoints.length >= 2) fetchRoute(); 
};

document.getElementById('resetRoute').onclick = ()=>{ 
  clearRoute(); 
  if(routingEnabled) searchBox.placeholder = "Select starting location"; 
};

// Search placeholder logic
function updateSearchPlaceholder(){
  if(!routingEnabled) searchBox.placeholder = "Search";
  else if(routingEnabled && !startMarker) searchBox.placeholder = "Select starting location";
  else if(routingEnabled && startMarker && !endMarker) searchBox.placeholder = "Select ending location";
  else searchBox.placeholder = "Search";
}

// Add pin function
function addPin(map, lngLat, isSearch = false) {
  let svgContent = defaultPinSVG;
  let draggable = routingEnabled;
  let pinTarget = null;

  if (routingEnabled) {
    if (!startMarker || (isSearch && searchBox.placeholder.toLowerCase().includes('starting'))) {
      pinTarget = 'start';
      svgContent = startPinSVG;
    } else if (!endMarker || (isSearch && searchBox.placeholder.toLowerCase().includes('ending'))) {
      pinTarget = 'end';
      svgContent = endPinSVG;
    } else if (!isSearch) {
      pinTarget = 'start';
      if(startMarker) startMarker.remove();
      svgContent = startPinSVG;
    }
  }

  const el = document.createElement('div');
  el.style.width = '40px';
  el.style.height = '40px';
  el.style.cursor = draggable ? 'move' : 'pointer';
  el.innerHTML = svgContent;

  const m = new maplibregl.Marker({ element: el, draggable: draggable }).setLngLat(lngLat).addTo(map);

  if (routingEnabled) {
    m.on('dragend', () => {
      const pos = [m.getLngLat().lng, m.getLngLat().lat];
      if (startMarker === m) {
        routePoints[0] = pos;
      } else if (endMarker === m) {
        routePoints[routePoints.length - 1] = pos;
      }
      if (routePoints.length >= 2) fetchRoute();
    });
  }

  // Assign to start/end and update routePoints
  if (pinTarget === 'start') {
    if (startMarker) startMarker.remove();
    startMarker = m;
    if(routePoints.length === 0) {
      routePoints = [[lngLat[0], lngLat[1]]];
    } else {
      routePoints[0] = [lngLat[0], lngLat[1]];
    }
    if (isSearch) searchBox.placeholder = "Select ending location";
  } else if (pinTarget === 'end') {
    if (endMarker) endMarker.remove();
    endMarker = m;
    if(routePoints.length === 1) {
      routePoints.push([lngLat[0], lngLat[1]]);
    } else {
      routePoints[routePoints.length - 1] = [lngLat[0], lngLat[1]];
    }
    if (isSearch) {
      searchBox.placeholder = "Search";
      fetchRoute();
    }
  }

  // Remove marker on click
  m.getElement().addEventListener('click', (e) => {
    e.stopPropagation();
    m.remove();
    if (startMarker === m) { 
      startMarker = null; 
      clearRoute();
    }
    if (endMarker === m) { 
      endMarker = null; 
      clearRoute();
    }
  });

  updateRouteButton();
}

// Clear route
function clearRoute(){
  waypointMarkers.forEach(wp => wp.remove());
  waypointMarkers = [];
  if(startMarker){ startMarker.remove(); startMarker = null; }
  if(endMarker){ endMarker.remove(); endMarker = null; }
  routePoints = [];
  routeInfo.style.display = 'none';
  hintText.style.display = 'none';
  [mapStreets,mapHybrid].forEach(m=>{ 
    if(m.getLayer('route')) m.removeLayer('route'); 
    if(m.getSource('route')) m.removeSource('route'); 
  });
  updateSearchPlaceholder();
}

// Fetch route with waypoints support
let loadingTimer = null;
function fetchRoute(){
  if(routePoints.length < 2) return;
  
  clearTimeout(loadingTimer);
  loadingTimer = setTimeout(()=>{ loadingEl.style.display='block'; }, 300);
  
  const url = `https://api.openrouteservice.org/v2/directions/${routingMode}/geojson`;
  const body = { coordinates: routePoints };
  
  fetch(url, {
    method:'POST', 
    headers: { 
      "Authorization": ORS_KEY, 
      "Content-Type": "application/json"
    }, 
    body: JSON.stringify(body)
  })
  .then(res => res.json())
  .then(data => {
    clearTimeout(loadingTimer); 
    loadingEl.style.display = 'none';
    
    if(!data.features || !data.features[0]) {
      console.error('No route found');
      return;
    }
    
    const feature = data.features[0];
    const routeGeoJSON = feature.geometry;
    const distanceKm = (feature.properties.summary.distance / 1000).toFixed(2);
    const durationMin = Math.round(feature.properties.summary.duration / 60);
    
    routeInfo.innerHTML = `Distance: ${distanceKm} km | Duration: ${durationMin} min`;
    routeInfo.style.display = 'block';
    hintText.style.display = 'block';
    
    [mapStreets, mapHybrid].forEach(m => {
      if(m.getSource('route')){ 
        m.removeLayer('route'); 
        m.removeSource('route'); 
      }
      m.addSource('route', {
        type: 'geojson', 
        data: {
          type: 'Feature', 
          geometry: routeGeoJSON
        }
      });
      m.addLayer({
        id: 'route', 
        type: 'line', 
        source: 'route', 
        layout: {
          'line-cap': 'round',
          'line-join': 'round'
        }, 
        paint: {
          'line-color': '#0074d9',
          'line-width': 5
        }
      });
    });
    
    // Fit route bounds
    const coords = routeGeoJSON.coordinates;
    const bounds = coords.reduce((b, c) => b.extend(c), new maplibregl.LngLatBounds(coords[0], coords[0]));
    const activeMap = currentStyle === 'streets' ? mapStreets : mapHybrid;
    activeMap.fitBounds(bounds, {padding: 100});
  })
  .catch(err => {
    clearTimeout(loadingTimer); 
    loadingEl.style.display = 'none';
    console.error('Route fetch error:', err);
  });
}

// Add waypoint function
function addWaypoint(lngLat) {
  if (!routingEnabled || !startMarker || !endMarker) return;

  const el = document.createElement('div');
  el.style.width = '28px';
  el.style.height = '28px';
  el.style.borderRadius = '50%';
  el.style.background = '#5856d6';
  el.style.border = '3px solid white';
  el.style.cursor = 'move';
  el.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';

  const map = currentStyle === 'streets' ? mapStreets : mapHybrid;
  const wp = new maplibregl.Marker({
    element: el,
    draggable: true
  })
    .setLngLat(lngLat)
    .addTo(map);

  // Insert waypoint before end point
  routePoints.splice(routePoints.length - 1, 0, [lngLat[0], lngLat[1]]);
  waypointMarkers.push(wp);

  wp.on('dragend', () => {
    const idx = waypointMarkers.indexOf(wp);
    if (idx !== -1) {
      routePoints[idx + 1] = [
        wp.getLngLat().lng,
        wp.getLngLat().lat
      ];
      fetchRoute();
    }
  });

  // Double-click to remove
  wp.getElement().addEventListener('dblclick', (e) => {
    e.stopPropagation();
    removeWaypoint(wp);
  });

  fetchRoute();
}

// Remove waypoint function
function removeWaypoint(wp) {
  const idx = waypointMarkers.indexOf(wp);
  if (idx === -1) return;

  wp.remove();
  waypointMarkers.splice(idx, 1);
  routePoints.splice(idx + 1, 1);

  fetchRoute();
}

// Map clicks - handle both regular clicks and shift+clicks
function onMapClick(e) {
  const map = currentStyle === 'streets' ? mapStreets : mapHybrid;
  
  // Shift+Click to add waypoint
  if (e.originalEvent.shiftKey) {
    if (routingEnabled && startMarker && endMarker) {
      addWaypoint([e.lngLat.lng, e.lngLat.lat]);
    }
    return;
  }
  
  // Regular click for start/end points
  if (!routingEnabled) return;
  addPin(map, [e.lngLat.lng, e.lngLat.lat], false);
}

[mapStreets, mapHybrid].forEach(m => m.on('click', onMapClick));

// Nominatim search
let debounceTimer;
searchBox.addEventListener('input', () => {
  updateSearchPlaceholder();
  clearTimeout(debounceTimer);
  debounceTimer = setTimeout(() => {
    const query = searchBox.value;
    if(!query) { searchResults.style.display = 'none'; return; }
    fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`)
      .then(res => res.json())
      .then(results => {
        searchResults.innerHTML = '';
        if(!results || results.length === 0) { searchResults.style.display = 'none'; return; }
        results.slice(0, 5).forEach(r => {
          const div = document.createElement('div');
          div.className = 'searchItem';
          div.textContent = r.display_name;
          div.onclick = () => {
            searchResults.style.display = 'none';
            const lngLat = [parseFloat(r.lon), parseFloat(r.lat)];
            const map = currentStyle === 'streets' ? mapStreets : mapHybrid;
            map.flyTo({ center: lngLat, zoom: 14 });

            addPin(map, lngLat, true);
            searchBox.value = '';
            updateSearchPlaceholder();
          };
          searchResults.appendChild(div);
        });
        searchResults.style.display = 'block';
      });
  }, 300);
});

document.addEventListener('click', e => { 
  if(!searchResults.contains(e.target) && e.target !== searchBox) 
    searchResults.style.display = 'none'; 
});

// Download map
document.getElementById('downloadMap').onclick = () => {
  const map = currentStyle === 'streets' ? mapStreets : mapHybrid;
  const canvas = map.getCanvas();
  canvas.toBlob(blob => {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'map.png';
    a.click();
    URL.revokeObjectURL(url);
  });
};
</script>
</body>
</html>
