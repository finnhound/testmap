<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<link href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" rel="stylesheet"/>
<script src="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>

<style>
html, body { margin:0; height:100%; font-family:'Inter', sans-serif; overflow: hidden; background: #000; }
.map { 
    width:100%; 
    height:100%; 
    position:absolute; 
    top:0; 
    left:0; 
    transition: transform 0.3s ease;
    contain: strict;
}

#pan-blocker { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 15; display: none; pointer-events: auto; }
#loading-bar { position: fixed; top: 0; left: 0; width: 0%; height: 6px; background: linear-gradient(90deg, #007aff, #5856d6); z-index: 200; transition: width 0.3s, opacity 0.3s; box-shadow: 0 2px 8px rgba(0,122,255,0.4); }
#speed-indicator {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.75);
    color: white;
    font: 600 22px Inter, sans-serif;
    padding: 10px 18px;
    border-radius: 20px;
    z-index: 200;
    pointer-events: none;
    backdrop-filter: blur(6px);
}

@media (min-width: 769px) {
    #speed-indicator {
        display: none; /* PC hidden */
    }
}
    
/* PC UI: Compact Top-Middle Pill - LARGER */
#controls { 
    position:absolute; 
    top:20px; 
    left:50%; 
    transform: translateX(-50%); 
    z-index:25; 
    background:white; 
    padding:10px 16px; 
    border:1px solid #ccc; 
    display:flex; 
    flex-direction:row; 
    align-items: center;
    gap:12px; 
    border-radius:30px; 
    box-shadow: 0 4px 16px rgba(0,0,0,0.2);
}

#searchBox { 
    width:200px; 
    padding:8px 12px; 
    border-radius:6px; 
    border:1px solid #ddd; 
    font-size: 14px;
    transition: border-color 0.2s, box-shadow 0.2s;
}
#searchBox:focus {
    outline: none;
    border-color: #007aff;
    box-shadow: 0 0 0 3px rgba(0,122,255,0.1);
}

#mode, #resetRoute {
    opacity: 0;
    max-width: 0;
    overflow: hidden;
    padding: 0;
    margin: 0;
    border: none;
    transition: opacity 0.3s ease, max-width 0.3s ease, padding 0.3s ease, margin 0.3s ease;
}

#mode.visible, #resetRoute.visible {
    opacity: 1;
    max-width: 200px;
    padding: 8px 14px;
    border: 1px solid #ddd;
}

#mode.visible {
    margin: 0;
}

#resetRoute.visible {
    margin: 0;
}

#searchResults { 
    position:absolute; 
    top:56px; /* Match search box height */
    left:0; 
    background:white; 
    border:1px solid #ddd; 
    max-height:200px; 
    overflow-y:auto; 
    width:100%; 
    z-index:100; 
    border-radius:12px; /* Match search box radius */
    display:none;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.searchItem {
    padding: 14px 18px; /* Appropriately scaled padding */
    cursor: pointer;
    border-bottom: 1px solid #f0f0f0;
    transition: background-color 0.15s;
    font-size: 15px; /* Scaled font for search results */
}
.searchItem:last-child { border-bottom: none; }
.searchItem:hover { background: linear-gradient(90deg, #f0f4ff, #f8f4ff); color: #007aff; }

button, select {
    padding: 8px 14px;
    border-radius: 6px;
    border: 1px solid #ddd;
    background: white;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s;
}
button:hover, select:hover { background: #f5f5f5; }
button:active { transform: scale(0.97); }

/* PC Route Info: Larger and more polished */
.route-info { 
    position:absolute; 
    top: 15px;
    right: auto;
    left: auto;
    transform: none;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 12px 24px; 
    font: bold 15px 'Inter', sans-serif; 
    z-index: 24; 
    border-radius: 25px; 
    display: none;
    box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    letter-spacing: 0.3px;
    opacity: 0;
    transition: opacity 0.35s ease, transform 0.35s ease;
    white-space: nowrap;
    max-width: calc(100vw - 700px);
    overflow: hidden;
    text-overflow: ellipsis;
}

.route-info.visible {
    opacity: 1;
    display: block;
}

.hint-text {
    position: absolute;
    top: 140px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255,255,255,0.95);
    padding: 6px 12px;
    border-radius: 15px;
    font-size: 12px;
    z-index: 23;
    display: none;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}

#routeFromLocation {
    position: absolute;
    top: 185px;
    right: 20px;
    z-index: 20;
    background: #00c7be;
    color: white;
    border: none;
    padding: 8px 14px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    display: none;
    box-shadow: 0 2px 8px rgba(0,199,190,0.3);
    transition: all 0.2s;
}
#routeFromLocation:hover {
    background: #00b0a4;
    transform: scale(1.05);
    box-shadow: 0 4px 12px rgba(0,199,190,0.4);
}
#routeFromLocation:active { transform: scale(0.95); }

#routeFromLocation {
    display: none !important;
}
    
/* PC Side Buttons - LARGER */
#downloadMap, #gpsToggle, #hybridToggle, #toggleRoute { 
    position:absolute; 
    right:20px; 
    z-index:20; 
    background:white; 
    border:1px solid #ccc; 
    cursor:pointer; 
    border-radius:10px; 
    width:44px; 
    height:44px; 
    display:flex; 
    align-items:center; 
    justify-content:center;
    transition: all 0.2s;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}
#downloadMap:hover, #gpsToggle:hover, #hybridToggle:hover, #toggleRoute:hover { 
    transform: scale(1.05); 
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}
#downloadMap:active, #gpsToggle:active, #hybridToggle:active, #toggleRoute:active { transform: scale(0.95); }

#toggleRoute { top:15px; }
#gpsToggle { top:70px; }
#downloadMap { top:125px; }
#hybridToggle { top:180px; }

#toggleRoute.active {
    background: #007aff;
}

#toggleRoute svg {
    width: 24px;
    height: 24px;
}

#toggleRoute.active svg {
    stroke: white;
}

#hybridToggle img {
    width: 24px;
    height: 24px;
}

#downloadMap svg,
#gpsToggle svg {
    width: 24px;
    height: 24px;
}
    
#gpsToggle.active { background: #007aff; }
#gpsToggle.active svg { stroke: white; }

.attribution-text { position:absolute; bottom:10px; right:10px; z-index:25; background:rgba(255,255,255,0.8); padding:4px 8px; font:10px 'Inter', sans-serif; border-radius:4px; }

/* MapTiler Logo: PC Bottom-Left */
.maptiler-logo { 
    position:absolute; 
    left:10px; 
    bottom:10px; 
    z-index:25; 
}
.maptiler-logo img { height: 20px; width: auto; display: block; }

    /* Add/Replace these in your <style> block */
.location-pin-wrapper {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 48px;  /* Increased size as requested */
    height: 48px;
    position: relative;
    cursor: pointer;
    overflow: visible; /* Ensure large accuracy circles aren't clipped */
}

.accuracy-circle {
    position: absolute;
    border-radius: 50%;
    background: rgba(0, 122, 255, 0.1);
    border: 1.5px solid rgba(0, 122, 255, 0.3);
    pointer-events: none; /* Allows clicking through the circle to the map */
    opacity: 0;
    transition: opacity 0.2s ease;
    z-index: -1; /* Keeps the circle behind the pin icon */
}

/* Show the circle when hovering over the pin's hit area */
.location-pin-wrapper:hover .accuracy-circle {
    opacity: 1;
}

/* ===============================
   MOBILE UI (PORTRAIT) ‚Äî UPDATED LAYOUT
   =============================== */
@media screen and (orientation: portrait) {

    html, body {
        background: #000;
        overflow: hidden;
    }

    /* ===============================
       MAP ‚Äî KEEP INTENTIONAL SCALING
       =============================== */
    #map-streets,
    #map-hybrid {
        width: 45.45%;
        height: 45.45%;
        transform: scale(2.2);
        transform-origin: top left;
        position: absolute;
    }

/* ===============================
       UNIFORM HUGE UI ‚Äî TOP RIGHT
       =============================== */
    #controls {
        position: fixed;
        top: 20px;
        right: 20px;
        left: auto; 
        
        /* Fixed width ensures all children (dropdown/button) match */
        width: 450px; 
        max-width: 65vw; 
        
        display: flex;
        flex-direction: column;
        gap: 15px; /* Consistent spacing between elements */
        padding: 20px;
        border-radius: 24px;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        z-index: 100;
        box-shadow: 0 15px 45px rgba(0,0,0,0.4);
    }

    #searchBox {
        width: 100%; /* Spans full width of #controls */
        height: 85px; /* Massive height */
        font-size: 32px !important;
        padding: 0 25px;
        border-radius: 16px;
        border: 2px solid #ddd;
        box-sizing: border-box; /* Crucial for uniformity */
    }

    /* DROPDOWN & RESET BUTTON UNIFORMITY */
    #mode, 
    #resetRoute {
        width: 100% !important; /* Forces same width as search bar */
        height: 75px !important; /* Slightly shorter than search for visual hierarchy */
        font-size: 28px !important;
        font-weight: bold;
        border-radius: 16px;
        margin: 0; /* Reset margins */
        padding: 0 20px;
        box-sizing: border-box;
        display: none; /* Controlled by .visible in JS */
    }

    /* Ensure display:block doesn't break the width when visible */
    #mode.visible, 
    #resetRoute.visible {
        display: block !important;
    }

    #searchResults {
        top: 115px; /* Adjusted for taller search box */
        width: 100%;
        border-radius: 16px;
    }

    .searchItem {
        padding: 25px;
        font-size: 28px;
    }

/* ===============================
   MOBILE ROUTE INFO PILL ‚Äî REAL DISAPPEAR FIX
   =============================== */
.route-info {
    position: fixed !important;
    top: 20px !important;
    left: 20px !important;

    font-size: 40px !important;
    font-weight: 900;
    color: white;

    height: 110px;
    padding: 0 48px;
    border-radius: 70px;

    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    text-align: center !important;

    line-height: 1 !important;
    white-space: nowrap;

    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    box-shadow: 0 12px 45px rgba(0,0,0,0.65);
    z-index: 160;

    /* üî• ACTUAL HIDE STATE */
    opacity: 0;
    visibility: hidden;
    transform: scale(0.92);
    pointer-events: none;

    transition:
        opacity 0.35s ease,
        transform 0.35s cubic-bezier(0.4, 0, 0.2, 1),
        visibility 0s linear 0.35s; /* delay hide */
}

/* üî• ACTUAL SHOW STATE */
body.route-active .route-info {
    opacity: 1;
    visibility: visible;
    transform: scale(1);
    pointer-events: auto;

    transition:
        opacity 0.35s ease,
        transform 0.35s cubic-bezier(0.4, 0, 0.2, 1),
        visibility 0s;
}
    
/* ===============================
   MOBILE SEARCH / ROUTING GUI ‚Äî FADE + SCALE TRANSITION
   =============================== */
#controls {
    position: fixed !important;
    top: 20px !important;
    right: 20px !important;
    left: auto !important;
    bottom: auto !important;

    transform: none !important; /* never center */
    margin: 0 !important;

    z-index: 150 !important;

    /* üî• ANIMATION */
    opacity: 1;
    transform-origin: top right;
    transition:
        opacity 0.35s ease,
        transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);
}

/* HIDDEN STATE (GPS MODE OR OFF) */
body.location-mode #controls,
body.routing-hidden #controls {
    opacity: 0;
    pointer-events: none;
    transform: scale(0.94);
}
    
/* ===============================
   HIDE ROUTING GUI DURING LOCATION MODE
   =============================== */
body.location-mode #controls {
    display: none !important;
}
    /* ===============================
       BOTTOM BUTTON BAR ‚Äî BOTTOM RIGHT MOBILE!!!
       =============================== */
    #toggleRoute,
    #gpsToggle,
    #downloadMap,
    #hybridToggle {
        position: fixed !important;
        right: 20px !important; /* BOTTOM RIGHT ALIGNMENT */
        width: 85px !important; /* Large buttons */
        height: 85px !important; /* Large buttons */
        z-index: 25 !important;
        transform: none !important;
        border-radius: 15px !important;
        left: auto !important;
        top: auto !important;
    }

    /* MOBILE BOTTOM RIGHT BUTTON STACK */
    #toggleRoute { 
        right: 20px !important; 
        bottom: 320px !important; 
        left: auto !important;
        top: auto !important;
    } 
    #gpsToggle    { 
        right: 20px !important; 
        bottom: 220px !important; 
        left: auto !important;
        top: auto !important;
    } 
    #downloadMap  { 
        right: 20px !important; 
        bottom: 120px !important; 
        left: auto !important;
        top: auto !important;
    } 
    #hybridToggle { 
        right: 20px !important; 
        bottom: 20px !important; 
        left: auto !important;
        top: auto !important;
    }

    /* Large icons for mobile */
    #toggleRoute svg,
    #gpsToggle svg,
    #downloadMap svg {
        width: 45px !important; /* Large icons */
        height: 45px !important; /* Large icons */
    }

    #hybridToggle img {
        width: 45px !important; /* Large icons */
        height: 45px !important; /* Large icons */
    }

    /* Disable hover/active scale conflicts */
    #toggleRoute:hover,
    #gpsToggle:hover,
    #downloadMap:hover,
    #hybridToggle:hover,
    #toggleRoute:active,
    #gpsToggle:active,
    #downloadMap:active,
    #hybridToggle:active {
        transform: none;
    }

    /* ===============================
       ATTRIBUTION ‚Äî MUCH LARGER
       =============================== */
    .attribution-text {
        position: fixed;
        bottom: 10px; /* Lower positioning */
        left: 50%;
        transform: translateX(-50%);
        font-size: 18px; /* Much larger font */
        padding: 14px 22px; /* Much larger padding */
        border-radius: 10px; /* Larger border radius */
        text-align: center;
        z-index: 20;
        font-weight: 500;
    }

    /* ===============================
       MAPTILER LOGO
       =============================== */
    .maptiler-logo {
        position: fixed;
        bottom: 90px; /* Adjusted for new button layout */
        left: 16px;
        transform: scale(1.4); /* Increased from 1.25 */
        transform-origin: bottom left;
    }

    /* ===============================
       HIDE DEFAULT MAP CONTROLS
       =============================== */
    .maplibregl-ctrl-group {
        display: none !important;
    }
}

</style>
<script src="https://sites.super.myninja.ai/_assets/ninja-daytona-script.js"></script>
</head>
<body>

<div id="speed-indicator"></div>
<div id="loading-bar"></div>
<div id="pan-blocker"></div>

<div id="map-streets" class="map"></div>
<div id="map-hybrid" class="map" style="display:none;"></div>

<div id="controls">
  <input id="searchBox" type="text" placeholder="Search"/>
  <div id="searchResults"></div>
  <select id="mode" style="display:none;">
    <option value="driving-car">üöó Car</option>
    <option value="foot-walking">üö∂ Walk</option>
    <option value="cycling-regular">üö¥ Bike</option>
  </select>
  <button id="resetRoute" style="display:none;">Reset</button>
</div>

<div id="downloadMap" title="Download Map">
  <svg viewBox="0 0 24 24" fill="none" stroke="#5856d6" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M9 11a3 3 0 1 0 6 0a3 3 0 0 0 -6 0"/><path d="M17.657 16.657l-4.243 4.243a2 2 0 0 1 -2.827 0l-4.244 -4.243a8 8 0 1 1 11.314 0z"/></svg>
</div>

<div id="toggleRoute" title="Toggle Routing">
  <svg viewBox="0 0 24 24" fill="none" stroke="#007aff" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="6" cy="19" r="3"></circle>
    <path d="M9 19h8.5a3.5 3.5 0 0 0 0-7h-11a3.5 3.5 0 0 1 0-7H15"></path>
    <circle cx="18" cy="5" r="3"></circle>
  </svg>
</div>

<div id="gpsToggle" title="GPS Location">
  <svg viewBox="0 0 24 24" fill="none" stroke="#007aff" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg>
</div>

<div id="hybridToggle"><img src="https://raw.githubusercontent.com/finnhound/cartohound/7b3c8e14c393450a26d9d562c99016afad43d83a/stack%20(1).svg" alt="Hybrid Map Icon"></div>

<button id="routeFromLocation">üìç Route from Location</button>

<div id="route-info" class="route-info"></div>

<div class="attribution-text">
    <a href="https://maplibre.org/" target="_blank">MapLibre</a> | 
    <a href="https://openrouteservice.org/" target="_blank">ORS</a> | 
    ¬© <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> | 
    ¬© <a href="https://www.maptiler.com/" target="_blank">MapTiler</a>
</div>
<a class="maptiler-logo" href="https://www.maptiler.com" target="_blank">
  <img src="https://api.maptiler.com/resources/logo.svg" alt="MapTiler logo">
</a>

<script>
const ORS_KEY = "eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6IjFjMzkyNDVlOGIyNjQxYjVhMDRhNWEwNjdlMTM4MDc0IiwiaCI6Im11cm11cjY0In0=";
const MT_KEY = 'OtdP8RQkvwYY4wHOxlrm';
const STREETS_URL = `https://api.maptiler.com/maps/019b2817-43ac-7a98-b15b-c204722a617b/style.json?key=${MT_KEY}`;
const HYBRID_URL = `https://api.maptiler.com/maps/hybrid/style.json?key=${MT_KEY}`;

const isMobile = window.matchMedia("(max-width: 768px)").matches || window.innerHeight > window.innerWidth;
const pinSize = isMobile ? 48 : 40;

const savedView = JSON.parse(localStorage.getItem('mapView') || 'null');
let currentStyle = localStorage.getItem('mapStyle') || 'streets';
let routingEnabled = JSON.parse(localStorage.getItem('mapRouteEnabled') || 'false');
let watchId = null;
let currentCoords = null;
let searchTimeout = null;
let locationMode = false;
let shouldPanToRoute = false; 

let routePoints = [];
let startMarker = null, endMarker = null, waypointMarkers = [];
let userMarkerStreets = null, userMarkerHybrid = null;
let locationPinStreets = null, locationPinHybrid = null;
let searchPinStreets = null, searchPinHybrid = null;
    let compassHeading = null;
let gpsHeading = null;
let gpsSpeedKmh = 0;

const mapStreets = new maplibregl.Map({ 
    container:'map-streets', 
    style:STREETS_URL, 
    center: savedView?.center||[0,0], 
    zoom: savedView?.zoom ?? 1, 
    attributionControl:false, 
    preserveDrawingBuffer:true,
    refreshExpiredTiles: false,
    maxTileCacheSize: isMobile ? 50 : 100
});

const mapHybrid = new maplibregl.Map({ 
    container:'map-hybrid', 
    style:HYBRID_URL, 
    center: savedView?.center||[0,0], 
    zoom: savedView?.zoom ?? 1, 
    attributionControl:false, 
    preserveDrawingBuffer:true,
    refreshExpiredTiles: false,
    maxTileCacheSize: isMobile ? 50 : 100
});

// LOCK VIEWPORT SIZE
const lockUI = () => {
    const doc = document.documentElement;
    doc.style.setProperty('--vh', `${window.innerHeight * 0.01}px`);
};
window.addEventListener('resize', lockUI);
lockUI();

// Disable focus-zoom on buttons
document.querySelectorAll('button, input, select').forEach(el => {
    el.addEventListener('focus', (e) => {
        if (isMobile) e.preventDefault();
    });
});

routingEnabled = false;
localStorage.setItem('mapRouteEnabled', 'false');

// PC-specific: Setup sliding controls
if (!isMobile) {
    const controls = document.getElementById('controls');
    controls.style.right = '90px';
    controls.style.left = 'auto';
    controls.style.transform = 'none';
    controls.style.transition = 'all 0.35s cubic-bezier(0.4, 0, 0.2, 1)';
    controls.style.width = 'auto';
    controls.style.top = '15px'; // Align with buttons
    
    // Position route info pill next to controls
    const routeInfo = document.getElementById('route-info');
    
    function positionRouteInfo() {
        const controlsRect = controls.getBoundingClientRect();
        const leftPosition = controlsRect.left - 20; // 20px gap from controls
        routeInfo.style.right = (window.innerWidth - leftPosition) + 'px';
    }

    if (isMobile) {
    const controls = document.getElementById('controls');
    const routeInfo = document.querySelector('.route-info');
    
    // Lock Search GUI to Top Right
    controls.style.top = '20px';
    controls.style.right = '20px';
    controls.style.left = 'auto';
    controls.style.bottom = 'auto';

    // Lock Route Info to Bottom Middle
    if (routeInfo) {
        routeInfo.style.bottom = '50px';
        routeInfo.style.left = '50%';
        routeInfo.style.transform = 'translateX(-50%)';
        routeInfo.style.top = 'auto'; // Clear any previous top setting
    }
}
    
    // Position initially and on window resize
    window.addEventListener('resize', positionRouteInfo);
    
    // Also reposition when controls expand/contract
    const observer = new MutationObserver(positionRouteInfo);
    observer.observe(controls, { attributes: true, childList: true, subtree: true });
    
    // Initial positioning
    setTimeout(positionRouteInfo, 100);
}

function clearRoute() {
    setMobileRouteInfoVisible(false);
    waypointMarkers.forEach(wp => wp.remove()); 
    waypointMarkers = [];
    if (startMarker) { startMarker.remove(); startMarker = null; }
    if (endMarker) { endMarker.remove(); endMarker = null; }
    routePoints = [];
    const routeInfo = document.getElementById('route-info');
    routeInfo.style.display = 'none';
    
    if (!isMobile) {
        routeInfo.classList.remove('visible');
        setTimeout(() => {
            routeInfo.style.display = 'none';
        }, 350);
    } else {
        routeInfo.style.display = 'none';
    }
    
    [mapStreets, mapHybrid].forEach(m => {
        if (m.getLayer('route-hitarea')) m.removeLayer('route-hitarea');
        if (m.getLayer('route')) m.removeLayer('route');
        if (m.getSource('route')) m.removeSource('route');
    });
    updateSearchPlaceholder();
}

clearRoute();

// Disable manual rotation/pitching on mobile
if (isMobile) {
    [mapStreets, mapHybrid].forEach(m => {
        m.touchZoomRotate.disableRotation();
        m.dragRotate.disable();
    });
}
if (!isMobile) {
    [mapStreets,mapHybrid].forEach(m=>{ m.addControl(new maplibregl.NavigationControl({showCompass:true, showZoom:true}),'top-left'); });
}

const arrowSVG = `
<svg width="${pinSize}" height="${pinSize}" viewBox="0 0 40 40">
    <circle cx="20" cy="20" r="10" fill="#007aff" stroke="white" stroke-width="3"/>
    <path d="M20 7L25 16H15L20 7Z"
          fill="#007aff"
          stroke="white"
          stroke-width="2"
          stroke-linejoin="round"/>
</svg>`;
const locationPinSVG = `<svg viewBox="0 0 24 24" fill="none" stroke="#007aff" stroke-width="3"><circle cx="12" cy="12" r="3"/><path d="M12 2v4M12 18v4M2 12h4M18 12h4"/></svg>`;
const searchPinSVG = `<svg viewBox="0 0 24 24" fill="none" stroke="#8b5cf6" stroke-width="3"><path d="M9 11a3 3 0 1 0 6 0a3 3 0 0 0 -6 0"/><path d="M17.657 16.657l-4.243 4.243a2 2 0 0 1 -2.827 0l-4.244 -4.243a8 8 0 1 1 11.314 0z"/></svg>`;

function setLoading(active) {
    const bar = document.getElementById('loading-bar');
    if (active) {
        bar.style.opacity = '1';
        bar.style.width = '70%';
    } else {
        bar.style.width = '100%';
        setTimeout(() => { bar.style.opacity = '0'; bar.style.width = '0%'; }, 300);
    }
}

function showHybrid(isHybrid) {
    document.getElementById('map-streets').style.display = isHybrid ? 'none' : 'block';
    document.getElementById('map-hybrid').style.display = isHybrid ? 'block' : 'none';
    document.getElementById('hybridToggle').classList.toggle('active', isHybrid);
    currentStyle = isHybrid ? 'hybrid' : 'streets';
    const activeMap = isHybrid ? mapHybrid : mapStreets;
    activeMap.resize();
    localStorage.setItem('mapStyle', currentStyle);
    if(startMarker) startMarker.addTo(activeMap);
    if(endMarker) endMarker.addTo(activeMap);
    waypointMarkers.forEach(wp => wp.addTo(activeMap));
    if(locationPinStreets) (isHybrid ? locationPinHybrid : locationPinStreets).addTo(activeMap);
    if(searchPinStreets) (isHybrid ? searchPinHybrid : searchPinStreets).addTo(activeMap);
}
showHybrid(currentStyle === 'hybrid');

let syncTimeout = null;

let Syncing = false;
const sync = (src, dest) => {
    if (Syncing) return;
    Syncing = true;
    
    try {
        const center = src.getCenter();
        const zoom = src.getZoom();
        const bearing = src.getBearing();
        
        // Only sync if values are valid
        if (center && !isNaN(center.lng) && !isNaN(center.lat) && !isNaN(zoom)) {
            dest.jumpTo({ 
                center: center, 
                zoom: zoom, 
                bearing: bearing 
            });
        }
    } catch (e) {
        console.error('Sync error:', e);
    }
    
    // Throttles sync to the screen refresh rate
    requestAnimationFrame(() => Syncing = false);
};

// Only sync when maps are loaded and ready
mapStreets.on('load', () => {
    mapStreets.on('move', () => {
        if (mapHybrid.loaded()) {
            sync(mapStreets, mapHybrid);
        }
    });
});

mapHybrid.on('load', () => {
    mapHybrid.on('move', () => {
        if (mapStreets.loaded()) {
            sync(mapHybrid, mapStreets);
        }
    });
});

// Save view on move end
function saveView() {
    try {
        const activeMap = currentStyle === 'streets' ? mapStreets : mapHybrid;
        const c = activeMap.getCenter();
        const z = activeMap.getZoom();
        
        if (c && !isNaN(c.lng) && !isNaN(c.lat) && !isNaN(z)) {
            localStorage.setItem('mapView', JSON.stringify({center: [c.lng, c.lat], zoom: z}));
        }
    } catch (e) {
        console.error('Save view error:', e);
    }
}

mapStreets.on('load', () => {
    mapStreets.on('moveend', saveView);
});

mapHybrid.on('load', () => {
    mapHybrid.on('moveend', saveView);
});

    function setMobileLocationMode(active) {
    if (!isMobile) return;
    document.body.classList.toggle('location-mode', active);
}

function setMobileRoutingVisible(visible) {
    if (!isMobile) return;
    document.body.classList.toggle('routing-hidden', !visible);
}

function updateSpeedDisplay() {
    if (!isMobile) return;

    const el = document.getElementById('speed-indicator');
    if (!el) return; // üîí prevents crash

    el.textContent =
        gpsSpeedKmh < 1
            ? '0 km/h'
            : `${gpsSpeedKmh.toFixed(1)} km/h`;
}

    
// --- GPS TRACKING ---

let lastHeading = null;

function handleOrientation(event) {
    if (!isMobile) return; // üîí PC unchanged

    let heading = null;

    // iOS (already tilt-compensated)
    if (event.webkitCompassHeading !== undefined) {
        heading = event.webkitCompassHeading;
    }
    // Android
    else if (event.alpha !== null) {
        heading = 360 - event.alpha;

        // Screen orientation correction
let screenAngle = 0;

if (typeof window.orientation === 'number') {
    screenAngle = window.orientation;
} else if (
    screen.orientation &&
    typeof screen.orientation.angle === 'number'
) {
    screenAngle = screen.orientation.angle;
}

        heading = (heading + screenAngle) % 360;
    }

    if (heading === null) return;

    // Smooth compass only
    if (compassHeading !== null) {
        let diff = heading - compassHeading;
        if (diff > 180) diff -= 360;
        if (diff < -180) diff += 360;
        heading = compassHeading + diff * 0.15;
    }

    compassHeading = heading;
}

document.getElementById('gpsToggle').onclick = async () => {
    if (isMobile) {
        // MOBILE: Toggle location lock mode
        const blocker = document.getElementById('pan-blocker');
        if (watchId !== null && locationMode) {
            navigator.geolocation.clearWatch(watchId);
            window.removeEventListener('deviceorientation', handleOrientation);
            watchId = null;
            currentCoords = null;
            locationMode = false;
            setMobileLocationMode(false);
            blocker.style.display = 'none';
            document.getElementById('gpsToggle').classList.remove('active');
            if (userMarkerStreets) { 
                userMarkerStreets.remove(); 
                userMarkerHybrid.remove(); 
            }
            userMarkerStreets = userMarkerHybrid = null;
            const activeMap = currentStyle === 'streets' ? mapStreets : mapHybrid;
            activeMap.setBearing(0);
            lastHeading = null;
        } else {
            setLoading(true);
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                const res = await DeviceOrientationEvent.requestPermission();
                if (res !== 'granted') { setLoading(false); return; }
            }
            document.getElementById('gpsToggle').classList.add('active');
            locationMode = true;
            setMobileLocationMode(true);
            blocker.style.display = 'block';
            window.addEventListener('deviceorientation', handleOrientation, true);
            
watchId = navigator.geolocation.watchPosition(pos => {
    setLoading(false);

    currentCoords = [
        pos.coords.longitude,
        pos.coords.latitude
    ];

    // --- SPEED (km/h) ---
    gpsSpeedKmh = pos.coords.speed
        ? pos.coords.speed * 3.6
        : 0;

    // --- GPS HEADING (only valid when moving) ---
    if (
        pos.coords.heading !== null &&
        gpsSpeedKmh >= 3
    ) {
        gpsHeading = pos.coords.heading;
    } else {
        gpsHeading = null;
    }

    // --- BLENDED HEADING ---
    let finalHeading = null;

    if (gpsHeading !== null) {
        finalHeading = gpsHeading;          // moving
    } else if (compassHeading !== null) {
        finalHeading = compassHeading;      // standing still
    }

    if (finalHeading !== null) {
        // Smooth final heading
        if (lastHeading !== null) {
            let diff = finalHeading - lastHeading;
            if (diff > 180) diff -= 360;
            if (diff < -180) diff += 360;
            finalHeading = lastHeading + diff * 0.2;
        }
        lastHeading = finalHeading;

        // Rotate user arrow
        if (userMarkerStreets) {
            userMarkerStreets.setRotation(finalHeading);
            userMarkerHybrid.setRotation(finalHeading);
        }

        // Rotate map (mobile only)
        if (locationMode && isMobile) {
            const activeMap =
                currentStyle === 'streets'
                    ? mapStreets
                    : mapHybrid;

            activeMap.easeTo({
                center: currentCoords,
                bearing: finalHeading,
                duration: 120,
                easing: t => t
            });
        }
    }

    // --- MARKER POSITION ---
    if (!userMarkerStreets) {
        const el1 = document.createElement('div');
        el1.innerHTML = arrowSVG;
        const el2 = document.createElement('div');
        el2.innerHTML = arrowSVG;

        userMarkerStreets = new maplibregl.Marker({
            element: el1,
            rotationAlignment: 'map'
        }).setLngLat(currentCoords).addTo(mapStreets);

        userMarkerHybrid = new maplibregl.Marker({
            element: el2,
            rotationAlignment: 'map'
        }).setLngLat(currentCoords).addTo(mapHybrid);

        const activeMap =
            currentStyle === 'streets'
                ? mapStreets
                : mapHybrid;

        activeMap.flyTo({
            center: currentCoords,
            zoom: 17,
            duration: 1200
        });
    } else {
        userMarkerStreets.setLngLat(currentCoords);
        userMarkerHybrid.setLngLat(currentCoords);
    }

    updateSpeedDisplay();

}, err => {
    setLoading(false);
    console.error('GPS error:', err);
}, {
    enableHighAccuracy: true,
    maximumAge: 0,
    timeout: 10000
});
    } else {
        // PC: Show location pin + route from location
        if (watchId !== null) {
            navigator.geolocation.clearWatch(watchId);
            watchId = null;
            currentCoords = null;
            if (locationPinStreets) {
                locationPinStreets.remove();
                locationPinHybrid.remove();
                locationPinStreets = locationPinHybrid = null;
            }
            document.getElementById('gpsToggle').classList.remove('active');
        } else {
            setLoading(true);
            navigator.geolocation.getCurrentPosition(pos => {
                setLoading(false);
                currentCoords = [pos.coords.longitude, pos.coords.latitude];
                
                const createPin = () => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'location-pin-wrapper';
                    wrapper.style.width = '60px';  // Larger hit area
                    wrapper.style.height = '60px';
                    
                    const circle = document.createElement('div');
                    circle.className = 'accuracy-circle';
                    
                    const icon = document.createElement('div');
                    icon.style.width = '40px'; // Larger Pin Icon
                    icon.style.height = '40px';
                    icon.innerHTML = locationPinSVG;
                    
                    wrapper.appendChild(circle);
                    wrapper.appendChild(icon);
                    return { wrapper, circle };
                };

                const res1 = createPin();
                const res2 = createPin();

                locationPinStreets = new maplibregl.Marker({ element: res1.wrapper, anchor: 'center' })
                    .setLngLat(currentCoords).addTo(mapStreets);
                locationPinHybrid = new maplibregl.Marker({ element: res2.wrapper, anchor: 'center' })
                    .setLngLat(currentCoords).addTo(mapHybrid);
                
                const updateAccuracy = () => {
                    try {
                        const map = currentStyle === 'streets' ? mapStreets : mapHybrid;
                        const zoom = map.getZoom();
                        if (!currentCoords || isNaN(zoom)) return;

                        const lat = currentCoords[1];
                        const metersPerPixel = 156543.03392 * Math.cos(lat * Math.PI / 180) / Math.pow(2, zoom);
                        const accuracyRadiusMeters = 125; 
                        const diameter = (accuracyRadiusMeters / metersPerPixel) * 2;
                        
                        [res1.circle, res2.circle].forEach(c => {
                            c.style.width = diameter + 'px';
                            c.style.height = diameter + 'px';
                        });
                    } catch (e) { console.error(e); }
                };

                mapStreets.on('zoom', updateAccuracy);
                mapHybrid.on('zoom', updateAccuracy);
                updateAccuracy();

                document.getElementById('gpsToggle').classList.add('active');
                const activeMap = currentStyle === 'streets' ? mapStreets : mapHybrid;
                activeMap.flyTo({center: currentCoords, zoom: 15, duration: 1500});

                watchId = navigator.geolocation.watchPosition(p => {
                    currentCoords = [p.coords.longitude, p.coords.latitude];
                    if (locationPinStreets) {
                        locationPinStreets.setLngLat(currentCoords);
                        locationPinHybrid.setLngLat(currentCoords);
                        updateAccuracy();
                    }
                }, null, { enableHighAccuracy: true });
            }, err => {
                setLoading(false);
                alert('Location error: ' + err.message);
            });
        }
    }
};

// --- ROUTING ENGINE ---
function rebuildRoutePoints() {
    // Always reconstruct the route from current marker positions
    routePoints = [];
    
    // Start point
    if (startMarker) {
        routePoints.push([startMarker.getLngLat().lng, startMarker.getLngLat().lat]);
    }
    
    // All waypoints in their current order
    waypointMarkers.forEach(wp => {
        routePoints.push([wp.getLngLat().lng, wp.getLngLat().lat]);
    });
    
    // End point
    if (endMarker) {
        routePoints.push([endMarker.getLngLat().lng, endMarker.getLngLat().lat]);
    }
}

function updateSearchPlaceholder() {
    const sb = document.getElementById('searchBox');
    if (!routingEnabled) sb.placeholder = "Search";
    else if (!startMarker) sb.placeholder = "Select start";
    else if (!endMarker) sb.placeholder = "Select end";
    else sb.placeholder = "Search";
}

function formatTime(minutes) {
    if (minutes > 59) {
        const hours = Math.floor(minutes / 60);
        const mins = Math.round(minutes % 60);
        return `${hours}h ${mins}min`;
    }
    return `${Math.round(minutes)} min`;
}

function fetchRoute() {
    // Only fetch if we have at least a start and an end
    if (routePoints.length < 2 || !routePoints[0] || !routePoints[routePoints.length - 1]) return;
    
    setLoading(true);
    
    fetch(`https://api.openrouteservice.org/v2/directions/${document.getElementById('mode').value}/geojson`, {
        method: 'POST',
        headers: { 
            "Authorization": ORS_KEY, 
            "Content-Type": "application/json" 
        },
        body: JSON.stringify({ coordinates: routePoints })
    })
    .then(res => {
        if (!res.ok) throw new Error("Routing failed");
        return res.json();
    })
    .then(data => {
        setLoading(false);
        if (!data.features || data.features.length === 0) return;
        
        const feat = data.features[0];
        
        // Update Info Box with formatted time
        const dist = (feat.properties.summary.distance / 1000).toFixed(1);
        const timeMinutes = feat.properties.summary.duration / 60;
        const timeStr = formatTime(timeMinutes);
        const routeInfo = document.getElementById('route-info');
        routeInfo.innerHTML = `<b>${dist} km</b> | ${timeStr}`;
        setMobileRouteInfoVisible(true);
        routeInfo.style.display = 'block';
        
        // Animate route info on PC and reposition
        if (!isMobile) {
            setTimeout(() => {
                routeInfo.classList.add('visible');
                // Reposition after content changes
                const controls = document.getElementById('controls');
                const controlsRect = controls.getBoundingClientRect();
                const leftPosition = controlsRect.left - 20;
                routeInfo.style.right = (window.innerWidth - leftPosition) + 'px';
            }, 50);
        } else {
            routeInfo.style.opacity = '1';
        }

        // Draw line on both maps
        [mapStreets, mapHybrid].forEach(m => {
            // Clean up old route safely
            if (m.getLayer('route-hitarea')) m.removeLayer('route-hitarea');
            if (m.getLayer('route')) m.removeLayer('route');
            if (m.getSource('route')) m.removeSource('route');

            m.addSource('route', { type: 'geojson', data: feat.geometry });

            /* Visible route */
            m.addLayer({
                id: 'route',
                type: 'line',
                source: 'route',
                layout: { 'line-join': 'round', 'line-cap': 'round' },
                paint: { 
                    'line-color': '#0074d9', 
                    'line-width': isMobile ? 8 : 5
                }
            });

            /* Invisible hit area for mobile taps */
            m.addLayer({
                id: 'route-hitarea',
                type: 'line',
                source: 'route',
                layout: { 'line-join': 'round', 'line-cap': 'round' },
                paint: {
                    'line-color': '#000',
                    'line-opacity': 0,
                    'line-width': isMobile ? 30 : 10
                }
            });
        });
        
        // Pan to fit route with padding
        const activeMap = currentStyle === 'streets' ? mapStreets : mapHybrid;
        const coordinates = feat.geometry.coordinates;
        const bounds = coordinates.reduce((bounds, coord) => {
            return bounds.extend(coord);
        }, new maplibregl.LngLatBounds(coordinates[0], coordinates[0]));
        
if (shouldPanToRoute) {
    activeMap.fitBounds(bounds, {
        padding: isMobile ? 120 : 100,
        duration: 1000
    });
    shouldPanToRoute = false;
}
    })
    .catch(err => {
        console.error("Fetch error:", err);
        setLoading(false);
    });
}

function setMobileRouteInfoVisible(visible) {
    if (!isMobile) return;
    document.body.classList.toggle('route-active', visible);
}
    
function addPin(lngLat, isSearch = false) {
    const activeMap = currentStyle === 'streets' ? mapStreets : mapHybrid;
    let type = (!startMarker || (isSearch && document.getElementById('searchBox').placeholder.includes('start'))) ? 'start' : 'end';
    
    const el = document.createElement('div');
    el.style.width = pinSize+'px'; 
    el.style.height = pinSize+'px';
    el.style.cursor = 'move';
    
    // Critical for mobile drag
    if (isMobile) {
        el.style.touchAction = 'none';
        el.style.userSelect = 'none';
        el.style.webkitUserSelect = 'none';
    }
    
    el.innerHTML = type === 'start' ? 
        `<svg viewBox="0 0 24 24" fill="none" stroke="#00c7be" stroke-width="3"><path d="M9 11a3 3 0 1 0 6 0a3 3 0 0 0 -6 0"/><path d="M17.657 16.657l-4.243 4.243a2 2 0 0 1 -2.827 0l-4.244 -4.243a8 8 0 1 1 11.314 0z"/></svg>` :
        `<svg viewBox="0 0 24 24" fill="none" stroke="#ff9500" stroke-width="3"><path d="M9 11a3 3 0 1 0 6 0a3 3 0 0 0 -6 0"/><path d="M17.657 16.657l-4.243 4.243a2 2 0 0 1 -2.827 0l-4.244 -4.243a8 8 0 1 1 11.314 0z"/></svg>`;
    
    const m = new maplibregl.Marker({ 
        element: el, 
        draggable: true,
        anchor: 'bottom'
    }).setLngLat(lngLat).addTo(activeMap);
    
    if (type === 'start') { 
        if(startMarker) startMarker.remove(); 
        startMarker = m;
        shouldPanToRoute = true;
        if(endMarker) {
            rebuildRoutePoints();
            fetchRoute();
        }
    } else { 
        if(endMarker) endMarker.remove(); 
        endMarker = m;
        shouldPanToRoute = true;
        if(startMarker) {
            rebuildRoutePoints();
            fetchRoute();
        }
    }
    
    m.on('dragend', () => {
        rebuildRoutePoints();
        shouldPanToRoute = true;
        fetchRoute();
    });
    
    // Better mobile tap handling
    if (isMobile) {
        m.on('drag', () => {
            // Provide feedback during drag
            el.style.opacity = '0.8';
        });
        m.on('dragend', () => {
            el.style.opacity = '1';
        });
    }
    
    updateSearchPlaceholder();
}

function addWaypoint(lngLat) {
    const activeMap = currentStyle === 'streets' ? mapStreets : mapHybrid;
    const el = document.createElement('div');
    
    // UI Styling: Smaller and semi-transparent on mobile
    el.style.cursor = 'move';
    el.style.borderRadius = '50%';
    el.style.boxShadow = '0 3px 10px rgba(0,0,0,0.4)';
    el.style.border = '3px solid white';
    
    if (isMobile) {
        // CRITICAL: Prevents the map from scrolling/panning while you drag the dot
        el.style.touchAction = 'none'; 
        el.style.width = '24px'; 
        el.style.height = '24px';
        el.style.background = '#8b8aeb';
        el.style.opacity = '0.7';
    } else {
        el.style.width = '22px'; 
        el.style.height = '22px';
        el.style.background = 'rgba(139, 138, 235, 0.9)'; 
    }

    const wp = new maplibregl.Marker({ 
        element: el, 
        draggable: true,
        anchor: 'center'
    }).setLngLat(lngLat).addTo(activeMap);

    // FIX: Insert point into the array correctly BEFORE the final destination
    const insertIndex = routePoints.length - 1;
    routePoints.splice(insertIndex, 0, lngLat);
    waypointMarkers.push(wp);

    // DRAG LOGIC: Move waypoint to finger position on mobile
    if (isMobile) {
        wp.on('drag', () => {
            el.style.opacity = '0.5';
        });
    }

    wp.on('dragend', () => {
        if (isMobile) el.style.opacity = '0.7';
        
        // Recalculate the entire route with updated waypoint positions
        rebuildRoutePoints();
        fetchRoute();
    });

    // CLICK LOGIC: Stop propagation to prevent "double-adding" points on mobile
    el.addEventListener('click', (e) => {
        e.stopPropagation(); 
        const idx = waypointMarkers.indexOf(wp);
        if (idx > -1) {
            waypointMarkers.splice(idx, 1);
            wp.remove();
            rebuildRoutePoints();
            fetchRoute();
        }
    });

    // Initial fetch for the new point
    fetchRoute();
}

[mapStreets, mapHybrid].forEach(m => m.on('click', (e) => {
    if (!routingEnabled) return;

    // FIX: Create a bounding box around the click point.
    // This is required for 'queryRenderedFeatures' to work on scaled CSS maps.
    const bbox = [
        [e.point.x - 10, e.point.y - 10],
        [e.point.x + 10, e.point.y + 10]
    ];

    if (startMarker && endMarker && m.getLayer('route')) {
        const layersToCheck = isMobile ? ['route', 'route-hitarea'] : ['route'];
        
        // Search the box instead of just the point
        const features = m.queryRenderedFeatures(bbox, { layers: layersToCheck });
        
        if (features.length > 0) { 
            // We hit the route! Add a waypoint.
            addWaypoint([e.lngLat.lng, e.lngLat.lat]); 
            return; 
        }
    }
    
    // If we didn't hit the route, add a normal start/end pin
    addPin([e.lngLat.lng, e.lngLat.lat]);
}));

document.getElementById('searchBox').addEventListener('input', (e) => {
    const q = e.target.value;
    clearTimeout(searchTimeout);
    if(!q) { 
        document.getElementById('searchResults').style.display = 'none'; 
        return; 
    }
    
    searchTimeout = setTimeout(() => {
        fetchSearchResults(q, e.target);
    }, 800);
});

function fetchSearchResults(query, searchInput) {
    setLoading(true);
    fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`)
        .then(r => r.json()).then(data => {
            setLoading(false);
            const res = document.getElementById('searchResults'); 
            res.innerHTML = '';
            
            // Store search results for Enter key handling and focus
            res.dataset.searchResults = JSON.stringify(data);
            
            data.slice(0,5).forEach(item => {
                const d = document.createElement('div'); 
                d.className = 'searchItem'; 
                d.textContent = item.display_name;
                d.onclick = () => {
                    handleSearchSelection(item, searchInput);
                };
                res.appendChild(d);
            });
            
            // Only show if search box is focused
            if (document.activeElement === searchInput) {
                res.style.display = 'block';
            }
        }).catch(() => setLoading(false));
}

// Handle Enter key in search box
document.getElementById('searchBox').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        const res = document.getElementById('searchResults');
        const searchResults = res.dataset.searchResults ? JSON.parse(res.dataset.searchResults) : null;
        
        if (searchResults && searchResults.length > 0) {
            // We have cached results, use them
            handleSearchSelection(searchResults[0], e.target);
            res.style.display = 'none';
        } else if (e.target.value) {
            // No cached results yet, fetch immediately
            clearTimeout(searchTimeout);
            setLoading(true);
            fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(e.target.value)}`)
                .then(r => r.json()).then(data => {
                    setLoading(false);
                    if (data && data.length > 0) {
                        // Go directly to first result
                        handleSearchSelection(data[0], e.target);
                        res.style.display = 'none';
                    }
                }).catch(() => setLoading(false));
        }
    }
});

// Hide search results when clicking outside
document.addEventListener('click', (e) => {
    const searchBox = document.getElementById('searchBox');
    const searchResults = document.getElementById('searchResults');
    
    if (!searchBox.contains(e.target) && !searchResults.contains(e.target)) {
        searchResults.style.display = 'none';
    }
});

// Show search results when clicking back into search box with text
document.getElementById('searchBox').addEventListener('focus', (e) => {
    const res = document.getElementById('searchResults');
    const searchResults = res.dataset.searchResults ? JSON.parse(res.dataset.searchResults) : null;
    
    if (e.target.value && searchResults && searchResults.length > 0) {
        res.style.display = 'block';
    }
});

function handleSearchSelection(item, searchInput) {
    const loc = [parseFloat(item.lon), parseFloat(item.lat)];
    const activeMap = currentStyle === 'streets' ? mapStreets : mapHybrid;
    
    // In routing mode, don't show search pin - just add route pin
    if (!routingEnabled) {
        // Remove existing search pins
        if (searchPinStreets) {
            searchPinStreets.remove();
            searchPinHybrid.remove();
        }
        
        // Create purple search pin
        const el1 = document.createElement('div');
        el1.style.width = '40px';
        el1.style.height = '40px';
        el1.innerHTML = searchPinSVG;
        
        const el2 = document.createElement('div');
        el2.style.width = '40px';
        el2.style.height = '40px';
        el2.innerHTML = searchPinSVG;
        
        searchPinStreets = new maplibregl.Marker({element: el1}).setLngLat(loc).addTo(mapStreets);
        searchPinHybrid = new maplibregl.Marker({element: el2}).setLngLat(loc).addTo(mapHybrid);
        
        // Make search pins clickable to remove
        [el1, el2].forEach(element => {
            element.style.cursor = 'pointer';
            element.addEventListener('click', (evt) => {
                evt.stopPropagation();
                if (searchPinStreets) {
                    searchPinStreets.remove();
                    searchPinHybrid.remove();
                    searchPinStreets = searchPinHybrid = null;
                }
            });
        });
    }
    
    activeMap.flyTo({center: loc, zoom: 14, duration: 1500});
    
    if(routingEnabled) addPin(loc, true);
    
    // Close dropdown and clear search
    document.getElementById('searchResults').style.display = 'none'; 
    searchInput.value = '';
    searchInput.blur(); // Remove focus from search box
}

document.getElementById('downloadMap').onclick = async () => {
    const activeMap = currentStyle === 'streets' ? mapStreets : mapHybrid;
    const originalZoom = activeMap.getZoom();
    const originalCenter = activeMap.getCenter();
    const originalBearing = activeMap.getBearing();
    const originalPitch = activeMap.getPitch();
    
    setLoading(true);
    
    // If current zoom is 15+ OR very zoomed out (< 13), just capture current view
    // Below zoom 13, buildings stop rendering so no point in high-res tiles
    if (originalZoom >= 15 || originalZoom < 13) {
        // Wait a moment for any pending renders
        await new Promise(resolve => setTimeout(resolve, 500));
        
        const mapCanvas = activeMap.getCanvas();
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = mapCanvas.width;
        tempCanvas.height = mapCanvas.height;
        const ctx = tempCanvas.getContext('2d');
        ctx.drawImage(mapCanvas, 0, 0);
        
        // Add attribution with FIXED small size
        const attr = "¬© MapLibre | ¬© ORS | ¬© OpenStreetMap | ¬© MapTiler";
        const fontSize = 14;
        const padding = 20;
        const boxHeight = 35;
        
        ctx.font = fontSize + "px Inter, sans-serif";
        const textWidth = ctx.measureText(attr).width;
        ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
        ctx.fillRect(tempCanvas.width - textWidth - padding, tempCanvas.height - boxHeight, textWidth + padding, boxHeight);
        ctx.fillStyle = "#333";
        ctx.fillText(attr, tempCanvas.width - textWidth - (padding/2), tempCanvas.height - 12);
        
        // Download
        const a = document.createElement('a');
        a.href = tempCanvas.toDataURL();
        a.download = `map-zoom${Math.round(originalZoom)}-${Date.now()}.png`;
        a.click();
        
        setLoading(false);
        return;
    }
    
    // For zoom levels 13-14, build high-res version at zoom 15
    const targetZoom = 15;
    const zoomDifference = targetZoom - originalZoom;
    const scaleFactor = Math.pow(2, zoomDifference);
    
    const originalWidth = activeMap.getContainer().offsetWidth;
    const originalHeight = activeMap.getContainer().offsetHeight;
    const newWidth = originalWidth * scaleFactor;
    const newHeight = originalHeight * scaleFactor;
    
    // Create a hidden container with the calculated size
    const hiddenContainer = document.createElement('div');
    hiddenContainer.style.width = newWidth + 'px';
    hiddenContainer.style.height = newHeight + 'px';
    hiddenContainer.style.position = 'absolute';
    hiddenContainer.style.top = '-99999px';
    hiddenContainer.style.left = '-99999px';
    document.body.appendChild(hiddenContainer);
    
    // Create temporary map at zoom 15 with same center
    const tempMap = new maplibregl.Map({
        container: hiddenContainer,
        style: currentStyle === 'streets' ? STREETS_URL : HYBRID_URL,
        center: originalCenter,
        zoom: targetZoom,
        bearing: originalBearing,
        pitch: originalPitch,
        attributionControl: false,
        preserveDrawingBuffer: true
    });
    
    // Wait for the temp map to fully load
    await new Promise((resolve) => {
        tempMap.on('load', () => {
            // If there's an active route, add it to the temp map
            if (activeMap.getSource('route')) {
                const routeData = activeMap.getSource('route')._data;
                tempMap.addSource('route', { type: 'geojson', data: routeData });
                tempMap.addLayer({
                    id: 'route',
                    type: 'line',
                    source: 'route',
                    layout: { 'line-join': 'round', 'line-cap': 'round' },
                    paint: { 
                        'line-color': '#0074d9', 
                        'line-width': 5
                    }
                });
            }
            
            // Wait for tiles and route to render
            setTimeout(resolve, 2000);
        });
    });
    
    // Capture the temp map's canvas
    const mapCanvas = tempMap.getCanvas();
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = mapCanvas.width;
    tempCanvas.height = mapCanvas.height;
    const ctx = tempCanvas.getContext('2d');
    ctx.drawImage(mapCanvas, 0, 0);
    
    // Add attribution with FIXED small size
    const attr = "¬© MapLibre | ¬© ORS | ¬© OpenStreetMap | ¬© MapTiler";
    const fontSize = 14; // Fixed size
    const padding = 20;
    const boxHeight = 35;
    
    ctx.font = fontSize + "px Inter, sans-serif";
    const textWidth = ctx.measureText(attr).width;
    ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
    ctx.fillRect(tempCanvas.width - textWidth - padding, tempCanvas.height - boxHeight, textWidth + padding, boxHeight);
    ctx.fillStyle = "#333";
    ctx.fillText(attr, tempCanvas.width - textWidth - (padding/2), tempCanvas.height - 12);
    
    // Clean up temp map
    tempMap.remove();
    document.body.removeChild(hiddenContainer);
    
    // Download
    const a = document.createElement('a');
    a.href = tempCanvas.toDataURL();
    a.download = `map-zoom${targetZoom}-${Date.now()}.png`;
    a.click();
    
    setLoading(false);
};

document.getElementById('toggleRoute').onclick = function() {
    routingEnabled = !routingEnabled;
    const mode = document.getElementById('mode');
    const reset = document.getElementById('resetRoute');
    
    if (routingEnabled) {
        setMobileRoutingVisible(true);
        this.classList.add('active');
        // GUI now works on both PC and Mobile
        mode.style.display = 'block';
        reset.style.display = 'block';
        
        void mode.offsetWidth; // Trigger reflow
        requestAnimationFrame(() => {
            mode.classList.add('visible');
            reset.classList.add('visible');
        });
    } else {
        setMobileRouteInfoVisible(false);
        setMobileRoutingVisible(false);
        this.classList.remove('active');
        mode.classList.remove('visible');
        reset.classList.remove('visible');
        
        setTimeout(() => {
            mode.style.display = 'none';
            reset.style.display = 'none';
        }, 350);
        clearRoute();
    }
    
    updateSearchPlaceholder();
    updateRouteFromLocationButton();
};

document.getElementById('resetRoute').onclick = clearRoute;
document.getElementById('hybridToggle').onclick = () => showHybrid(currentStyle === 'streets');
document.getElementById('mode').onchange = () => { 
    if (startMarker && endMarker) {
        shouldPanToRoute = true;
        fetchRoute();
    }
};

// Route from location button
document.getElementById('routeFromLocation').onclick = async () => {
    if (!currentCoords) {
        // Get location first
        setLoading(true);
        navigator.geolocation.getCurrentPosition(pos => {
            setLoading(false);
            currentCoords = [pos.coords.longitude, pos.coords.latitude];
            
            // Enable routing if not already
            if (!routingEnabled) {
                routingEnabled = true;
                document.getElementById('toggleRoute').textContent = 'Disable Routing';
                updateSearchPlaceholder();
            }
            
            // Set as start point
            if (startMarker) startMarker.remove();
            addPin(currentCoords, false);
            
            const activeMap = currentStyle === 'streets' ? mapStreets : mapHybrid;
            activeMap.flyTo({center: currentCoords, zoom: 14, duration: 1000});
        }, err => {
            setLoading(false);
            alert('Unable to get location: ' + err.message);
        }, { enableHighAccuracy: true });
    } else {
        // Already have location
        if (!routingEnabled) {
            routingEnabled = true;
            document.getElementById('toggleRoute').textContent = 'Disable Routing';
            updateSearchPlaceholder();
        }
        
        if (startMarker) startMarker.remove();
        addPin(currentCoords, false);
        
        const activeMap = currentStyle === 'streets' ? mapStreets : mapHybrid;
        activeMap.flyTo({center: currentCoords, zoom: 14, duration: 1000});
    }
};

// Show route from location button when GPS is active and routing is enabled (PC only)
function updateRouteFromLocationButton() {
    const btn = document.getElementById('routeFromLocation');
    if (!isMobile && routingEnabled && (currentCoords || watchId !== null)) {
        btn.style.display = 'block';
    } else {
        btn.style.display = 'none';
    }
}

updateRouteFromLocationButton();
</script>
</body>
</html>
